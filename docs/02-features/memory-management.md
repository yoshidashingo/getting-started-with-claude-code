# メモリ管理機能

Claude Codeの階層型メモリシステムとコンテキスト管理について説明します。メモリ機能を活用することで、プロジェクト固有の知識やコーディング規約をClaude Codeに記憶させ、より効率的な開発支援を受けることができます。

## 概要

Claude Codeのメモリシステムは、4つの階層で構成されており、上位のメモリほど優先的に読み込まれます。

### メモリ階層

1. **エンタープライズポリシーメモリ** (最優先)
   - システム全体のポリシーと標準
   - 組織全体で共有される規約

2. **プロジェクトメモリ**
   - チームレベルの規約と知識
   - プロジェクト固有の設定

3. **ユーザーメモリ**
   - 個人の好みや作業スタイル
   - プロジェクト横断的な個人設定

4. **ローカルプロジェクトメモリ** (非推奨)
   - 特定のディレクトリ固有の設定

## CLAUDE.mdファイル

### 基本的な使い方

プロジェクトのルートディレクトリに`CLAUDE.md`ファイルを作成することで、プロジェクト固有の情報をClaude Codeに記憶させることができます。

```markdown
# プロジェクト情報

## 概要
このプロジェクトは、ECサイトのバックエンドAPIです。

## 技術スタック
- Node.js 20.x
- TypeScript 5.x
- Express.js
- PostgreSQL
- Redis

## コーディング規約
- 関数名はcamelCaseを使用
- ファイル名はkebab-caseを使用
- すべてのAPIレスポンスは標準フォーマットに従う

## プロジェクト構造
```
src/
├── controllers/  # APIコントローラー
├── services/     # ビジネスロジック
├── models/       # データモデル
└── utils/        # ユーティリティ関数
```

## 重要な注意事項
- 本番環境のデータベースには直接接続しない
- すべてのAPIエンドポイントには認証が必要
```

### メモリファイルの自動検出

Claude Codeは起動時に以下の順序でメモリファイルを検索します：

1. 現在のディレクトリから上位ディレクトリに向かって再帰的に検索
2. 各階層のメモリファイルを優先順位に従って読み込み
3. 最大5階層までのインポートをサポート

## クイックメモリ追加

### #コマンドの使用

対話中に`#`を使用して、素早くメモリに情報を追加できます：

```
# このプロジェクトではJestを使用してテストを書いています
```

この情報は現在のセッションのメモリに追加され、以降の対話で参照されます。

## /memoryコマンド

### メモリファイルの編集

```
/memory
```

このコマンドを実行すると、現在のメモリファイルを編集できます。

### メモリの確認

```
/memory show
```

現在読み込まれているメモリの内容を確認できます。

## メモリインポート機能

### @記法によるインポート

他のメモリファイルをインポートして再利用できます：

```markdown
# プロジェクトメモリ

@../shared-memory/coding-standards.md
@../shared-memory/security-guidelines.md

## プロジェクト固有の設定
このプロジェクト特有の設定をここに記述...
```

### インポートの利点

- 共通設定の一元管理
- DRY原則の適用
- チーム間での知識共有

### インポートの制限

- 最大5ホップまでの再帰的インポート
- 循環参照は自動的に検出・防止
- 相対パスと絶対パスの両方をサポート

## メモリコンパクション

### 自動最適化

Claude Codeは以下の場合に自動的にメモリを最適化します：

- メモリサイズが大きくなりすぎた場合
- 重複する情報が検出された場合
- 古い情報が新しい情報で上書きされた場合

### 手動での最適化

長期間のプロジェクトでは、定期的にメモリファイルを見直すことを推奨します：

1. 不要になった情報の削除
2. 重複する内容の統合
3. より具体的な指示への更新

## ベストプラクティス

### 1. 構造化された記述

```markdown
## API設計原則
- RESTful設計に従う
- バージョニングはURLパスで行う（/api/v1/）
- エラーレスポンスは統一フォーマットを使用

## データベース規約
- テーブル名は複数形（users, products）
- 外部キーは`_id`サフィックス（user_id）
- タイムスタンプは必須（created_at, updated_at）
```

### 2. 具体的な例の提供

```markdown
## エラーハンドリング

良い例：
```typescript
try {
  const result = await userService.create(userData);
  return res.status(201).json({ success: true, data: result });
} catch (error) {
  logger.error('User creation failed:', error);
  return res.status(400).json({ 
    success: false, 
    error: error.message,
    code: 'USER_CREATION_FAILED'
  });
}
```
```

### 3. 否定的な指示の回避

❌ 悪い例：
```markdown
- グローバル変数を使わない
- console.logを残さない
```

✅ 良い例：
```markdown
- すべての変数はスコープ内で宣言
- ロギングにはloggerインスタンスを使用
```

### 4. 定期的な更新

プロジェクトの進化に合わせて、メモリファイルも更新しましょう：

- 新しい技術スタックの追加
- 変更されたコーディング規約の反映
- 学んだ教訓の記録

## トラブルシューティング

### メモリが読み込まれない場合

1. ファイル名が正確に`CLAUDE.md`であることを確認
2. ファイルのエンコーディングがUTF-8であることを確認
3. ファイルのパーミッションを確認

### メモリの競合

複数の階層で同じ設定がある場合、上位の階層が優先されます：

```
エンタープライズ > プロジェクト > ユーザー > ローカル
```

### パフォーマンスの問題

メモリファイルが大きすぎる場合：

1. 不要な情報を削除
2. 共通部分を別ファイルに分離してインポート
3. より簡潔な記述に更新

## 高度な活用例

### プロジェクトテンプレート

```markdown
# プロジェクトテンプレート

@templates/backend-api.md
@templates/testing-setup.md
@templates/deployment-config.md

## このプロジェクトのカスタマイズ
- ポート番号: 3001
- データベース名: myapp_dev
- 特殊な環境変数: FEATURE_FLAG_X=true
```

### チーム共有設定

```markdown
# チーム共有メモリ

## コードレビュー基準
1. すべての関数にJSDocコメント
2. 複雑なロジックには説明コメント
3. テストカバレッジ80%以上

## Git運用
- feature/ブランチから開発
- コミットメッセージは[type]: descriptionフォーマット
- PRには必ずテスト結果を含める
```

---

**関連ドキュメント:**
- [プロジェクトコンテキスト](project-context.md) - プロジェクト全体の理解
- [スラッシュコマンド](slash-commands.md) - その他のコマンド
- [設定ファイル詳細](../12-configuration.md) - 詳細な設定オプション